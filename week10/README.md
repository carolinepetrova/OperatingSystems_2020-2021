# Системни примитиви за работа с файлове в Linux

**Как да компилираме C програма?**
```
cc file.c -o output_executable
```

**Какво е системен примитив?**

Системните примитиви (системни извиквания (system calls)) са фундаменталния интерфейс между програма и ядрото на Linux-a (ядрото е програма, която предоставя основни услуги на другите програми). Т.е чрез системните примитиви ядрото предоставя услуги на приложните програми. 

**Защо на C?**

Освен, че Linux e написан на С, за всеки системен примитив има поне една функция в стандартната библиотека на C. Ние ще пишем програми, които съдържат обръщения към тези системни примитиви. 

## Oсновни понятия
**Файлов дескриптор** - Неотрицателно цяло число, което служи за уникален идентификатор на отворен файл. Файловите дескриптори имат локално значение за процесите – всеки процес разполага с N файлови дескриптора. Всеки процес стандартно има отворени три дескриптора:
-   0 (стандартен вход)

-   1 (стандартен изход)

-   2 (стандартен изход за грешки)

Когато отворим файл той заема най-ниският файлов дескриптор, който е свободен. 

**Текуща позиция във файл** (**file offset**) - определя позицията във файла, от която ще бъде четено или записвано.

**Режим на отваряне** - определя начина на достъп до файла чрез съответния файлов дескриптор докато е отворен от процеса

## Системни примитиви за работа с (обикновени) файлове

### Създаване на файл
```
int creat(const char *filename, mode_t mode);
```

- Създава обикновен файл с име **filename** с режим **mode**.

- Връща дескриптора на файла или -1 при грешка.

Ако такъв файл вече съществува, то старото му съдържание се унищожава при условие, че процесът има право за писане във файла. Създаденият файл се отваря само за писане и creat връща файлов дескриптор свързан с файла.


### Отваряне на файл
```
#include <fcntl.h>
int open(const char *filename, int oflag [, mode_t mode]);
```

- Отваря файл с име **filename** в режим **oflag**, а ако не съществува го създава с режим **mode**.

- връща файловия дескриптор или -1 при неуспех

**oflag** указва режима на отваряне и/или действия, които да се извършат след отваряне:

-   O_RDONLY - само за четене

-   O_WRONLY - само за писане

-   O_RDWR - за четене и писане

-   O_CREAT - създава файла

-   O_EXCL - заедно с O_CREAT: ако файлът  **не съществува**, той се създава, иначе се връща грешка

-   O_TRUNC - старото съдържание на файла се изтрива след отваряне

-   O_APPEND - старото съдържание се запазва, а новото се вписва в края на файла

-   O_SYNC - всяко писане е синхронно 


### Четене от файл

```
#include <unistd.h>
ssize_t read(int  fd, void * buffer, size_t nbytes);  
```
-   **fd**  - номер на файлов дескриптор

-   **buffer**  - указател към  областта от програмата, където се записват данните

-   **nbytes**  - указва броя байтове за четене

- връща броя на **реално** прочетените байтове, иначе връща -1

### Писане във файл

```
ssize_t write(int fd, void *buffer, size_t nbytes);
```
-   **fd**  - номер на файлов дескриптор

-   **buffer**  - указател към  областта от програмата, където се записват данните

-   **nbytes**  - указва броя байтове за писане

- връща броя на **реално** записаните байтове, иначе връща -1 

### Позициониране във файл

```
off_t lseek(int fd, off_t offset, int flag);
```

-   **fd**  - номер на файлов дескриптор

- **offset** - самото отместване

- **flag** -  указва как се интерпретира отместването

	- **SEEK_SET** - премества указателя от началото до offset-байта

	- **SEEK_CUR** - премества указателя от сегашната му позиция до offset-байта

	-  **SEEK_END** - премества указателя от края на файла (отзад-напред) до offset-байта (отрицателно число)
	
**Как да намерим къде се намира указателя в момента?**

```
lseek(fd, 0, SEEK_CUR);
```

**Как да намерим размера на файла? **

```
lseek(fd, 0, SEEK_END);
```

### Затваряне на файл

```
int close(int fd);
```

## Задачи: 
1. Да се напише програма на C, която реализира командата cat без аргументи

2. Да се напише програма на C, която реализира командата tee файл

3. Да се напише програма на C, която реализира командата cat [файл] [...]

4. Да се напише програма на C, която реализира командата cut -c m-n файл. (m и n да се четат от входа)
