# Метасимволи и генериране на имена на файлове. Стартиране във фонов дял. Пренасочване на вход/изход. Конвейер между процеси.

## Метасимволи  
Метасимволите (wildcards) са символи със специално значение за shell.
### Генериране на имена на файлове с метасимволи

|Символ|Значение  |
|--|--|
| * | нула или повече символи |
| ? | точно един символ |
| [] | някой символ измежду тези в скобите |
| [^]| всичко друго освен това в скобите |

**Примери:**

- `а*` - всичко, което започва с а

- `??*` - всичко, което има поне два символа в името си

- `[a-c]*` - всичко, което започва с a,b или c

- `[afs]?` - всичко, което започва с a,f или s и съдържа точно 2 символа

- `[a-z][0-9].txt` - текстови файлове, съдържащи се точно от 2 символа - първият е буква, вторият е цифра 

**Как можем да ги използваме?**
- `cp a* dir` - копирай всичко от текущата, чието име започва с "а" в директория dir

- `file [a-z]*[A-Z].txt` покажи ми информация за всеки файл от текущата директория, който започва с малка буква и завършва с голяма буква

- `rm *.txt` изтрий всички файлове от текущата директория, чието разширение е .txt

- `find / -name ??` търси в цялата файлова система файлове и директории, чието име е точно 2 символа

### Други метасимволи (ще ги използваме по-активно от следващия път)
|Символ|Значение  |
|--|--|
| \`cmd\` | Субституция на команда |
| $(cmd) | Субституция на команда |
| ; | Последователност от команди |
| \#| Коментар |
|$|достъпва стойността на променлива|


## Escape-ване на метасимволи
Понякога не искате метасимволите да имат специално значение. Примерно ако ви се наложи да умножите нещо използвайки само `*` няма да се получи.

За да премахнем специалното значение на метасимволите поставяме `\` пред тях.  Примерно: `\?`, `\*`, `\>` ...

В стрингове не е нужно да използвате навсякъде `\` за да escape-нете метасимволите:

- Единичните кавички `' '` - защитават всички символи без \

- Двойните кавички `" "` - защитават всичко, без \, $ и `

## Пренасочване на вход/изход
Meтасимволи за пренасочване на вход/изход
|Символ|Значение  |
|--|--|
| > | Пренасочване на изхода (пренаписва) |
| >> | Пренасочване на изхода (закача) |
| < | Пренасочване на входа |

При изпълнението на програма или команда в Линукс тя е свързана автоматично към 3 потока от данни - stdin (стандартен вход), stdout (стандартен изход), stderr (стандартен изход за грешки). 
Стандартните потоци на процесите могат да бъдат пренасочвани във файлове:

- Стандартният вход (stdin) се пренасочва чрез "<" към файл, откъдето процесът трябва да чете
	
	Пример: когато използваме cat без аргументи, командата чете низове от стандартния вход и ги принтира на стандартния изход. 
	
	`cat < f1` - stdin за cat става файла f1, а stdout си е стандартния изход. Командата извежда съдържанието на файла. 

- Стандартния изход (stdout) се пренасочва с ">" към файл. Ако файлът не съществува се създава, иначе се презаписва. Ако не искаме файла да се презаписва, а да добавяме към края му, се използва ">>". 

	`cat > f1` - стандартния вход е клавиатурата, а стандартния изход става файлът f1, т.е. пишем последователно във файла f1. 
	
	`ps aux >> f1` - стандартния изход за ps aux става файла f1, като сме указали информацията да се добави към края на съдържанието му. 

- можем да пренасочим и двата потока едновременно

	`cat < f1 > f2` - stdin за cat е f1, a stdout е f2, т.е. симулирахме cp командата

**Какво става със стандартния поток за грешки?** 

Ако изпълним командата `find / -name f1 > ff` виждаме че stdout е пренасочен към файла ff, a на екрана ни излизат само съобщения за грешки. Най-често стандартния поток за грешки се пренасочва чрез **файловия му дескриптор**

**Какво е файлов дескриптор?**

Файловият дескриптор е цяло, неотрицателно число, което служи за идентифициране на отворен файл. 

Както споменах по-горе всеки процес има 3 предварително отворени файла: 
	- stdin е с дескриптор 0 
	- stdout е с дексриптор 1
	- stderr е с дескриптор 2

Всеки процес може да отваря и други файлове, като на тях ще им се присвоява съответно най-малкото свободно число ... но това е тема, която ще се разглежда по Системно програмиране. 

Та горните примери съответно могат да изглеждат по този начин:

`cat 0<f1` - принтираме съдържанието на f1

`cat 1>f1` - записваме низове, подадени от стандартния вход в f1

`ps aux 1>>f1` - записваме информацията от ps aux в края на f1 

И съответно, за да пренасочим грешките в друг файл:

`find / -name f1 > ff 2>errors.txt` - така имаме файл ff, който съдържа желаните резултати и файл errors.txt, който съдържа всички грешки от изпълнението на find. 

## Конвейер между процеси. 
Meтасимвол за конвейер между процеси.

|Символ|Значение  |
|--|--|
| \| | Конвейер. Изхода на една команда става вход на друга |

Конвейерът е последователност от процеси, свързани чрез техните потоци, така че стандартния изход от единия процес става стандартен вход на следващия процес. 

Синтаксисът е следният: `command1 | command 2 | command 3` 

Пример: Искаме да преброим колко файла имаме в текущата директория. Това може да стане по следния начин:

    ls > temp
    wc -l < temp 
    rm temp

Вместо да създаваме временен файл можем да свържем стандартния изход на ls със стандартния вход на wc: 

    ls | wc -l

## Задачи
1. Копирайте всички файлове от родителската директория на вашата начална потребителска директория, чието име има поне един символ и завършва с разширение .txt в дикектория copyResult.

2. Копирайте всички файлове, чието име започва с цифра и завършва с главна буква, от главната директория и всички нейни поддиректории. Направете така, че на екрана да не излизат грешки.

3. Запишете във файл f1 колко файла с разширение txt и с поне един символ в текущата ви директория съдържат код на езика С. (търси се по "c program")

4. Стартирайте редактора vim във фонов режим. Добавете (append) PID-то на процеса (без да го търсите ръчно) във файл f1.

5. Проверете дали файла passwd.txt е сортиран лексикографски. Запишете резултата от сравнението във файл isSorted. След това добавете в този файл САМО броя на редовете на passwd.txt

6. Изпратете pid на текущите процеси на всички потребители до потребител по ваш избор (бонус ако го изпратите до друг терминал, в който сте логнати). Забележка: Разделителите в таблицата с информация за процесите са повече от един whitespace. Трябва да се погрижите за махането на повтарящите се whitespace, за да получите правилната информация.
