# Условия и цикли

## Условен оператор if

**Синтаксис:**
```
if команда 
then
действие (команда 2)
[elif 
команда3 
then
команда4]
...
[else 
командаN]
fi
```

**ВАЖНО**

If, while и until проверяват изходното състояние на команда. Ако то е нула командите в телата им се изпълняват.
Т.е ако условието ви е:
``` if ls -l somedir ```
ако изходния код на командата е 0, то то ще се изпълни това, което е в тялото на if-a. 

**Забележка:** if, while, until не пренасочва стандартния изход на командата, която сте подали като "условие". Това означава, че резултатът на командата ще се изпринтира на стандартния изход. 


**Пример:**
```
file=/etc/passwd
if grep Georgi $file 
then
echo "There are names containing Georgi in $file"
else 
echo "No matches were found"
fi
```

## Командата test

За да можем да правим промерки (каквито сме свикнали по принцип) използваме командата test.

Синтаксис: `test <израз>`

Особености: 

- командата не връща нищо, но има код на изход: 

	- 0: истина (тестът е бил успешен)

	- 1: лъжа (тестът е бил неуспешен)


- взимаме кода чрез $? 

 - за сравняване на стойности главно се използват **опции**, а за низове се използват **oператори**

### Оператори и опции, които се използват за сравнения: 

| Сравняване за цели числа | Функция   |
|--|--|
| -gt (greater than) | по-голямо от |
| -lt (less than) | по-малко от |
| -ge (greater or equal) | по-голямо или равно |
| -le (less or equal) | по-малко или равно |
| -eq (equal) | равно |
| -ne (not equal) | неравно |

| Сравняване на низове | Функция  |
|--|--|
| -z | проверява за празен низ |
| -n | проверява за непразен низ |
| = | равни низове |
| != | различни низове |
| < и > | сравнява лексикографски низовете |

| Проверки за файлове   | Функция  |
|--|--|
| -f | файлът съществува |
| -s | файлът не е празен |
| -d | файлът е директория |
| -r | файлът може да се чете |
| -w | във файлът може да се записва |
| -x | файлът може да се изпълнява |

| Логически оператор   | Функция  |
|--|--|
| ! | логическо отрицание |
| -а | логическо И |
| -o | логическо ИЛИ |


**Синтаксис:**
```
$ test value1 -option value2  
$ test string operator string
```
**Пример:**
```
file=/etc/passwd
if test -s $file -a $(grep Georgi $file | wc -l) -ne 0
then
echo "The file is not empty and there are names containing Georgi in $file"
else 
echo "No matches were found"
fi
```


### За по-четлив и прост запис вместо командата test може да се използват квадратните скоби ([ ]).

Приемете, че "[" е "друго име" на командата **test**, затова, когато пишете проверка трябва да има място пред и зад [. Затварящата квадратна скоба играе роля на финален аргумент за "[". 


**Примери:**
```
$ [ value1 -option value2 ]
$ [ string operator string ]
```
```
file=/etc/passwd
if [ -s $file -a $(grep Georgi $file | wc -l) -ne 0 ]
then
echo "The file is not empty and there are names containing Georgi in $file"
else 
echo "No matches were found"
fi
```
```
read num1 num2
if [ $num1 -eq $num2 ]
then
echo "Numbers from stdin are equal"
elif  [ $num1 -lt $num2 ]
then
echo " $num1 < $num2 "
else 
echo " $num1 > $num2 "
fi
```

## Оператор за избор case

**Синтаксис:**

```
case стойност in  
шаблон1 | шаблон2 | ...) 
команда
;;  
[…]  
esac
```

**Пример:**

Създаване на командна процедура, която по подадено име на държава от стандартния изход, дава информация, кой е официалният език на държавата.
```sh
read country
case $country in 
USA | UK | Australia )
echo "The official language of $country is English"
;;
Romania | Moldova)
echo "The official language of $country is Romanian"
;;
China)
echo "The official language of China is Mandarin"
*)
echo "We don't have data about $country
;;
esac
```

## Цикли

### while цикъл 

**Синтаксис:**
```sh
while условие(команда)
do
   команда1 
   команда2
   команда3
   ...
done
```

Пример:
```sh 
x=0
while [ $x -le 5 ]
do
echo $x
x=$(expr $x + 1)
done
```
### until цикъл 
**Синтаксис:**
```sh
until условие(команда)
do
   команда1 
   команда2
   команда3
   ...
done
```
**Пример:**
```
read user
until who | grep $user 
do
echo "Waiting for user $user to login"
sleep 10
done
```

**Каква е разликата между while и until?**

Противоположни са си. While се изпълнява докато условието е вярно, а until се изпълнява, докато условието е грешно. 

### for цикъл

**Синтаксис:**
```
for променлива in [списък]
do 
команда1
команда2
...
done
```

**Примери:**
```
for i in 1 2 3 4 5
do 
echo $i
done
```
Изход:

1
2
3
4
5

```
read user1 user2 user3
file=/etc/passwd
for user in $user1 $user2 $user3
write $user < $file
done
```
Изход: изпраща съдържанието на файла /etc/passwd на потребителите, прочетени от стандартния вход

```
x=1
for args in $@
echo "command line argument $x is $args"
x=$(expr $x + 1)
done
```
Изход: принтира на стандартния изход позиционните параметри подадени на командната процедура

```
for i 
do 
echo $i
done
```
е същото като 
```
for i in $@
do 
echo $i
done
```
## break, continue и sleep

### break [n]
- Прекъсва n-тият цикъл отвътре-навън

- ако не е зададен n то се прекъсва цикъла, в който е сложен break

### continue [n]

- skip-ват се всички команди след него и се продължава следващата итерация на n-тия цикъл отвътре-навън

- ако не е зададен n то се продължава с 1 итерация напред

### sleep n 

Паузира процеса за n секунди


## Задачи:
1. Да се състави командна процедура, която получава при стартиране в командния ред два параметъра - имена на съществуващи файлове. В случай, че общият брой на файловете, съдържащи ASCII текст в двете директории надвишава 20, процедурата създава в текущата директория файл sources.txt съдържащ имената им, който да е достъпен само за четене от всички потребители. В противен случай извежда с подходящо съобщение броя на тези файлове. 
2. Да се състави командна процедура, която получава в командния ред при стартиране един параметър - символен низ. Ако не съществува директория с подаденото име в началната потребителска директория, процедурата я създава. Копира в нея тези файлове от началната потребителска директория (само от там), чиито размер е по-голям от 50 байта като в същото време изписва името на копирания файл. 
3. Да се напише командна процедура, който получава произволен брой аргументи файлове, които изтрива при дадени условия:
Ако бъде подадена празна директория, тя бива изтрита. Ако подадения файл е директория с поне 1 файл, тя не се изтрива.
За всеки изтрит файл (директория) скриптът добавя ред във файл с име logs с подходящо съобщение.

